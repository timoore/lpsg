@begin(section)
@title(Overview)

LPSG is a Common Lisp library for rendering graphics using OpenGL. It
presents a programming interface that allows it to implement
optimizations that are important on modern graphics hardware. LPSG's
target applications include 3D content creation programs, games, and
geospatial viewing programs -- in short, any domain in which excellent
interactive rendering of complex scenes is required. Another
important class of applications that LPSG will support is 2D
applications such as text editors which need fast, portable rendering.

Note: LPSG is a work in progress. Throughout this manual future work or
features will be indicated @i([like this.])

While LPSG does provide classes and functions for common 3D rendering
tasks, its essential purpose is to aid the creation of fast programs
that use OpenGL. A typical application that uses LPSG will specialize
a few LPSG public classes and generic functions in order to inject
some OpenGL code, such as a custom shader program, into LPSG's
rendering code.

The main optimization goal pursued by LPSG is to reduce the memory
traffic between the CPU and GPU. It does this by storing the user's
data in OpenGL @i(buffer objects) which normally reside on the
GPU. Most updates to a graphics view, such as matrices that specify
eye or object positions, are small; these are handled through a system
of parameters called @i(usets). On the other hand, LPSG does @([will])
support efficient methods for uploading large updates of user data.

Another important optimization is reducing CPU cache misses during
rendering. This is often caused by traversing large tree-like
structures or scene graphs in the user's application. LPSG uses a
different approach: the application @i(submits) graphics objects to
LPSG, which is from then on responsible for traversing the objects and
displaying them. LPSG can use data structures that are more efficient
than the application's, @i([and much of the traversal may even be
moved to the GPU.]) Newer versions of OpenGL contain interfaces that
can reduce the number of cache misses inside the driver itself,
@i([LPSG will take of advantage of them.])

An optimization which was historically crucial and is still helpful is
reducing the number of state changes in the graphics
hardware. Changing the rendering destination, current shader program,
or set of bound textures requires reinitializing a lot of hardware state and
may cause a stall on the GPU. @i([LPSG will sort the rendering order
of graphics objects to minimize state changes.])

A side effect of all these optimizations is to reduce the number of calls
to the OpenGL API. This is good for OpenGL performance in general, as
each OpenGL call requires work from the driver to at least validate it and
check for errors. This is especially good in Common Lisp, as "foreign
function calls" can be quite expensive.

@begin{section}
@title{Conventions}
LPSG is described in terms of protocols and protocol classes. A
@i{protocol} is a set of generic functions that collaborate to do
something. The functions in a protocol must restrict some of their
arguments to classes that have certain properties. These classes are
@i{protocol classes}, abstract classes that serve only as
superclasses. A protocol class defines accessors, which behave like
normal slot accessors, although they can take more than one
argument. It also defines normal generic functions that are considered
to be part of the class, even though classes don't implement functions
and methods in Common Lisp.

If a class inherits from a protocol class, then there must exist
applicable methods for all the accessors and generic functions defined
by the protocol class when the derived class appears as an argument to
them. LPSG provides mixins that contain slots whose accessor methods
implement the protocol classes' accessor generic functions.

Protocol classes are defined using the @{define-protocol-class} macro:

@cl:with-package[name="lpsg"](
@cl:doc(macro define-protocol-class)
)

LPSG provides instantiable classes that are subclasses of its protocol
classes. These have names beginning with "standard-" or "simple-" and
are documented along with the protocol classes.
@end{section}

@begin{section}
@title{High level LPSG}

LPSG contains a @c{renderer} class that controls all rendering to the
screen. The user creates @c{shapes} containing per-vertex attributes,
such as position or color data. The shape also contains an effect
object which controls its appearence on the screen.

Once a shape has been prepared, it is submitted to the renderer. This
invokes the @c{submit-with-effect} generic function which, dispatching
on the renderer, shape, and effect arguments, creates the objects that
are used in the actual OpenGL rendering and places them on various
queues. These are used when the user calls the renderer's @c{draw}
method: OpenGL objects are created on the GPU, any necessary
initialization is performed, and shapes are rendered. On future calls
to @c{draw}, these objects will be rendered again. The user
effectively gives up ownership of a shape object until the
@c{retract} method is called on it. This removes the objects created
in the @c{submit} call from the renderer's queues and destroys any
now-uneeded OpenGL objects.

Scenes in 3D applications are very dynamic; if they weren't, there
wouldn't be much point in displaying them in 3D. At the least, it is
possible for the viewpoint to change at every redraw of the
screen. The geometric objects in the scene may be animated as well,
and these are often evaluated within systems of nested coordinate systems. To
support this dynamism, LPSG implements a system of parameters that are
connected in dependency chains. These @c{incremental-node} objects use
lazy evaluation to supply values that affect OpenGL rendering. These
values are most often used to set the uniform variables in OpenGL
shader programs. LPSG aggregates such variables into sets, in order to
choose the optimal way to upload them to OpenGL; these sets are called
"uniform sets" or, throughout LPSG, "usets."

@end{section}
@begin{section}
@title{The renderer}

The @c{renderer} class that controls all rendering to the
screen. Generic functions that dispatch on @c{renderer} ultimately
perform all OpenGL calls. @c{open-renderer} performs any OpenGL
initialization needed; @c{close-renderer} cleans up when the
application is finished rendering.

The user calls the @c{submit} method to register objects with a
renderer. Geometric objects, called "shapes," that have been submitted
will then be rendered when the @c{draw} generic function is
called. Submitted objects persist between calls to @{draw}.

The @c{retract} generic function removes an object from a
@c{renderer}. It will not be rendered anymore, and any OpenGL objects
used by it will be deallocated if not used by any other LPSG
objects. This deallocation is not immediate because it relies on
garbage collection to notice when an object is no longer used.


@cl:with-package[name="lpsg"](
@cl:doc(class renderer)
@cl:doc(generic open-renderer)
@cl:doc(generic close-renderer)
@cl:doc(generic draw)
@cl:doc(class standard-renderer)
@cl:doc(generic submit)
@cl:doc{generic retract}
)

The environment object is not used directly during OpenGL
rendering. It does control how the rendering will be done. This is
accomplished in the "submit" method, when a shape is submitted to the
renderer. Submit immediately calls another method called
"submit-with-effect". This method can be specialized on the effect
object. This method has access to the internal data structures of the
renderer at that point. This includes are queues that will be
traversed in order to render shapes on the screen. That is, one of the
queues contain shapes (????XXX), but when submit-with-effect is
called, the effect actually creates another object, called an
"environment," which does contain everything needed for OpenGL to
render a shape e.g., : the shader program needed to render the shape,
the texture units in effect, the collection of usets needed by the
shader program.

@end{section}

@end(section)

@begin{section}
@title{Attributes and shapes}

The @c{shape} class represents geometry that is rendred by OpenGL. In
that sense it contains a collection of vertex attributes i.e. the
per-vertex data used in the rendering.  This might include a position in space
(coordinates); a surface normal vector, colors, texture coordinates,
or anything else in this modern world of shaders that could possibly
be stored per-vertex in a shape. Each vertex attribute is stored in a
@c{vertex-attribute} object.

@begin{section}
@title{Buffers}

@cl:with-package[name="lpsg"](
@cl:doc(class buffer-area)
@cl:doc(class mirrored-resource
)

@end{section}

The shape also contains an object called a "drawable" which describes
the specific shape i.e., whether it is a collection of points, lines,
or triangles, how many of these objects there are, and also whether
the shape is indexed or not. This refers to whether the vertex
attributes are just straight arrays of one value for every vertex in
the shape, or whether the individual parts of the shape are described
by indices which are indexes into the arrays of vertex
attributes. Indexed shapes are important because not only do they
offer a big size savings on meshes where a lot of the vertices would
be repeated in the shape, they also enable another class of
optimizations where the vertex attributes can be shared among
different shapes. 

A shape is registered with the renderer using the @code{submit} method. After
that, at that point lpsg handles everything. There only two things
that can be directly done to the shape. It's visibility can be changed
by a visible accessor on the shape, which controls whether it is
actually displayed. There is also a retract method, which removes the
shape from lpsg, causes to not be displayed anymore; at that point,
it's over for the shape.

@cl:with-package[name="lpsg"](
@cl:doc(generic gl-buffer)
@cl:doc(generic buffer)
@cl:doc(generic attribute)
@cl:doc(generic data)
@cl:doc(generic attributes)
@cl:doc(class vertex-attribute)
@cl:doc(class shape)
@cl:doc(class standard-shape)
)
@end{section}

@begin{section}
@title{Incremental computation}

Now, one of the things we are trying to optimize in lpsg is the amount
of memory traffic to the GPU. So, we don't want to send copies of
usets at every frame if we don't have to. So, there is a system of
lazy evaluation in lpsg called "incremental nodes," which ultimately
connect up to the environment object and feed it values. Normally an
application would change the value of a uset; what this does
is,through a chain of connected incremental nodes, causes the change
to be registered for upload at a future time.

@cl:with-package[name="lpsg"](
@cl:doc(class if-then-node)
@cl:doc(class then)
@cl:doc(class else)
@cl:doc(class sink-node)
@cl:doc(class sink-node-mixin)
@cl:doc(class source-node)
@cl:doc(class source-node-mixin)
@cl:doc(class source-sink-mixin)
@cl:doc(class computation-node)
@cl:doc(class computation-node-mixin)
@cl:doc(generic delete-sink)
@cl:doc(generic value)
@cl:doc(generic compute)
@cl:doc(generic notify-invalid-input)
@cl:doc(class input-value-node)
@cl:doc(generic input)
@cl:doc(function input-value)
)

@end{section}

@begin{section}
@title{Uniform sets}

This is all not very useful in terms of writing 3D
applications. because if you put a shape on the screen with all these
immutable attributes, then you can't navigate in the scene! You can't
move the objects, no animation, can't do anything. This problem is
resolved in lpsg by specifying parameters that end up affecting the
environment. The parameters are grouped into sets, which we call
"uniform sets," or "usets" as is used throughout lpsg. The idea is
that parameters that are related to each other are grouped into sets
and can eventually be updated in OpenGL in the same time, or at with
the same frequency, and can be stored together. Uniform sets comes
from the name that variables have in shader programs: "uniform
variables." These are variables that change slowly; they do not change
in the course of the rendering of a single shape. Their values might
change between different shapes. And this is how an environment object
could be used to render different shapes on the screen because one
parameter of the environment would have to be the model matrix, which
specifies where the object is in space. This is a parameter that is
different for every shape, and it could change during the execution of
the user's program. Another example of a uset are the parameters
describing the viewpoint and camera. These are usually know as the
view matrix and projection matrix. -- As well as other matrices
associated with the camera, such as an inverse, transposed matrix used
to transform normal vectors.

@cl:with-package[name="lpsg"](
@cl:doc(macro define-uset)
)
   
@end{section}

@begin{section}
@title{The submit protocol}

@begin{section}
@title{Environments}


The third major part of a shape is an object called an "environment,"
which ultimately controls the appearance of the shape. The environment
contains things such as the shader program, the textures bound when
the shape is rendered... Some of these members are immutable, others
are not. The general idea is that the shape itself is immutable, once
it is created, and certainly once it has been submitted to lpsg. The
individual parts of the shape are not necessarily immutable; the
drawable part is mutable, and one can change the number of primitives
drawn, which might be useful in some special effects to hide parts of
a shape. The vertex attributes can be mutable. It is important to be
able to upload new data for many kinds of dynamic animation
effects. The environment is immutable; it is intended to be created
and after is "read-only" (???)

   #:gl-state

Submit-with-effect, then, has the freedom ---

I mispoke, it's not shapes that go on the queues... will talk about
that in a second. What submit-with-effect does is it takes from the
shape it creates additional objects that are similar to shapes, but,
in the backend of lpsg, that are called "bundles." The bundles are
placed in the queues. Along with a bundle is an environment object
which contains everything needed by OpenGL to render the shape. 

@end{section}


@end{section}

@begin{section}
@title{OpenGL State}
@cl:with-package[name="lpsg"](
@cl:doc(class graphics-state)
@cl:doc(generic units)
@cl:doc(class texture-area)
@cl:doc(class texture-2d)
@cl:doc(class sampler)
)

@end{section}
@begin{section}
@title{Utilities}

@cl:with-package[name="lpsg"](
@cl:doc(generic compute-shape-allocation)
@cl:doc(class simple-allocator)
@cl:doc(class interleaved-attribute-allocator)
@cl:doc(generic open-allocator)
@cl:doc(generic allocate-target)
@cl:doc(generic close-allocator)
@cl:doc(macro with-allocator)
@cl:doc(generic make-cube-shape)
   )
@end{section}
